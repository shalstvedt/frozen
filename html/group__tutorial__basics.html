<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>frozen: Tutorial: overview, basic i/o, processing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">frozen&#160;<span id="projectnumber">1.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial: overview, basic i/o, processing</div>  </div>
<div class="ingroups"><a class="el" href="group__tutorial.html">Tutorials</a></div></div>
<div class="contents">
<table class="memberdecls">
</table>
<h2><a class="anchor" id="tutorial_basics_overview"></a>
Overview</h2>
<p>To construct necessary tool frozen have many different building blocks, called backends. Backends can connect to each other and form nearly any configuration, like a graph. To describe which backends would be used and where connection must exist user fill configuration file. Because of "one-dimensional" property of files this is not so trivial as it could be done in GUI. So, configuration written in form of "chains" - list of blocks with connections first to second, second to third and so on. Configuration file can contain any number of chain with any length. To separate different chains special keyword NULL used.</p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &#39;request/debug&#39; },
{ <span class="keyword">class </span>=  &quot;io/stdout&quot; },
NULL,
{ <span class="keyword">class </span>: &quot;io/stdout&quot; }
</pre></div><p>Note different string quotes and assignment marks.</p>
<p>Next, if you want to one backend have many childs, you need supply two chains: both of them would contain this backend and each of them would contain one of child backends. But this backend should be named. To name backend you need to write "name" parameter and unique name for it.</p>
<p>Following example demonstrate "debug" backend named "mynamehere" with two childs both "stdout": </p>
<div class="fragment"><pre class="fragment">{ name  =&gt; <span class="stringliteral">&quot;mynamehere&quot;</span>                          },
{ <span class="keyword">class </span>=&gt; &quot;io/stdout&quot;                           },
NULL,
{ <span class="keyword">class </span>=&gt; &quot;request/debug&quot;, name =&gt; <span class="stringliteral">&quot;mynamehere&quot;</span> },
{ <span class="keyword">class </span>=&gt; &quot;io/stdout&quot;                           }
</pre></div><p>Configuration file parsed from bottom to top, so, every named objects must be already created at bottom to be used properly. Some of backends can be defined at bottom of file separately, and lately used in chains. Active backends, for example cache, can't be used such way because on start it is trying fill cache with underlying backend's data.</p>
<h2><a class="anchor" id="tutorial_basics_exec"></a>
Executing configuration</h2>
<p>To actually execute some configuration you should write it to configuration file and type in your shell following: </p>
<div class="fragment"><pre class="fragment">   $ frozend -c configuration_file.conf
</pre></div><p> <b>frozend</b> here is frozen daemon which parse configration file and create backends. <b>frozend --help</b> for more daemon options.</p>
<p>If you use <a class="el" href="group__mod__backend__stdin.html">io/stdin</a> in configuration, pass input as usual. Same for <a class="el" href="group__mod__backend__stdout.html">io/stdout</a>, <a class="el" href="group__mod__backend__stderr.html">io/stderr</a>. </p>
<div class="fragment"><pre class="fragment">   $ cat file | frozend -c configuration_file.conf
   $ cat file | frozend -c configuration_file.conf  &gt;log_stdout
   $ cat file | frozend -c configuration_file.conf 2&gt;log_stderr
</pre></div><h2><a class="anchor" id="tutorial_basics_input"></a>
Input</h2>
<p><em>Stdin</em> </p>
<p>To have anything to be parsed it should be somehow passed in backend. Frozen have different ways in input data, most simple one is console. <a class="el" href="group__mod__backend__stdin.html">io/stdin</a> used to get data from stdin. And because stdin module is passive, <a class="el" href="group__mod__backend__transfer.html">data/transfer</a> with <a class="el" href="group__mod__backend__thread.html">daemon/thread</a> used to activly transfer data from one backend chain to another. In this case destination is <a class="el" href="group__mod__backend__stdout.html">io/stdout</a> used. For more about outputs read next chapter.</p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;data/transfer&quot;,
        source = {
                { <span class="keyword">class </span>=&gt; &quot;io/stdin&quot;                         }
        },
        destination = {
                { <span class="keyword">class </span>=&gt; &quot;io/stdout&quot;                        }
        }
}
</pre></div><p><em>Fuse</em> </p>
<p>Next way is <a class="el" href="group__mod__backend__fuse.html">io/fuse</a> backend. It create filesystem using fuse and pass all read and writes to user defined backends. Sample configuration can look like so:</p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>= &quot;fuse&quot;, mountpoint = <span class="stringliteral">&quot;/home/test/&quot;</span>, items = {
        { path = <span class="stringliteral">&quot;/one&quot;</span>, backend = {
                { <span class="keyword">class </span>= &quot;io/stdout&quot; }
        }}
}}
</pre></div><p>This creates file system in /home/test folder, which contain file named "one" and every write request to this file will result in console output. Use "echo 'hello' &gt;&gt; /home/test/one" or similar to test it.</p>
<p><em>Emitter</em> </p>
<p>One more way to input is describe backend which send requests you want. One of such backends is <a class="el" href="group__mod__backend__emitter.html">request/emitter</a>. Example: </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;request/emitter&quot;,
        request = {
                request = { buffer = <span class="stringliteral">&quot;Hello, world!\n&quot;</span> },
                backend = {
                        { <span class="keyword">class </span>=&gt; &quot;io/stdout&quot; }
                }
        }
},
{ <span class="keyword">class </span>=&gt; &quot;daemon/kill&quot; }
</pre></div><p><em>HTTP</em> </p>
<p>Another way is different modules, for example go_http. It create simple web server and pass request to user's backends. </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class</span>=<span class="stringliteral">&quot;go_http&quot;</span>, addr=<span class="stringliteral">&quot;127.0.0.1:12345&quot;</span> },
{ <span class="keyword">class</span>=<span class="stringliteral">&quot;debug&quot;</span> }
</pre></div><p><em>File</em> </p>
<p>You could read data from file and use it as input data. Construction is same as for stdin. </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;data/transfer&quot;,
        source = {
                { <span class="keyword">class </span>=&gt; &quot;file&quot;, filename = <span class="stringliteral">&quot;TODO&quot;</span> }
        },
        destination = {
                { <span class="keyword">class </span>=&gt; &quot;io/stdout&quot; }
        }
}
</pre></div><h2><a class="anchor" id="tutorial_basics_output"></a>
Output</h2>
<p><em>Debugging</em> </p>
<p>To debug request flow you can use <a class="el" href="group__mod__backend__debug.html">request/debug</a> backend. It print line in stderr on request arrival, and optionally on request end. Also it can show request content. Example: </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;data/transfer&quot;,
        source = {
                { <span class="keyword">class </span>=&gt; &quot;io/stdin&quot;  }
        },
        destination = {
                { <span class="keyword">class </span>=&gt; &quot;request/debug&quot;  }
        }
}
</pre></div><p><em>Stdout</em> </p>
<p>This could be done by <a class="el" href="group__mod__backend__stdout.html">io/stdout</a>. It print buffer in console stdout. For stderr - use <a class="el" href="group__mod__backend__stderr.html">io/stderr</a>. </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;data/transfer&quot;,
        source = {
                { <span class="keyword">class </span>=&gt; &quot;file&quot;, filename = <span class="stringliteral">&quot;TODO&quot;</span> }
        },
        destination = {
                { <span class="keyword">class </span>=&gt; &quot;io/stdout&quot; }
        }
}
</pre></div><p><em>File</em> </p>
<p>Write data to file with <a class="el" href="group__mod__backend__file.html">storage/file</a> backend. Example: </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;data/transfer&quot;,
        source = {
                { <span class="keyword">class </span>=&gt; &quot;io/stdin&quot; }
        },
        destination = {
                { <span class="keyword">class </span>=&gt; &quot;file&quot;, filename = <span class="stringliteral">&quot;example_out_file.dat&quot;</span> }
        }
}
</pre></div><h2><a class="anchor" id="tutorial_basics_processing"></a>
Processing</h2>
<p><em>Split</em> </p>
<p>It is very common to process data line-by-line, especially in UNIX world, but for performance reasons frozen by default don't split incoming data on lines. If you want lines you should use <a class="el" href="group__mod__backend__split.html">data/split</a> backend. By default it split input exactly by <br/>
 which mean end of line.</p>
<p><em>Regexp</em> </p>
<p>To match some input for pattern you can use <a class="el" href="group__mod__backend__regexp.html">data/regexp</a>. It add special marker to current request if data match defined pattern.</p>
<p><em>Conditions</em> </p>
<p>As we have some markers, where got to be some condition. <a class="el" href="group__mod__backend__switch.html">request/switch</a> control request flow using conditions. Because flow could be redirected in any other backend chain you could do anything with such request or enviroment, for example terminate request, return success or error, write this to logger, trigger some action and so on.</p>
<h2><a class="anchor" id="tutorial_basics_combine"></a>
Combining all together</h2>
<p>As we know some of processing and input backends we could combine it in something useful. For example, you want to know which users have /bin/false shell. Configuration will look like following: </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &quot;data/transfer&quot;,
        source = {
                { <span class="keyword">class </span>=&gt; &quot;file&quot;, filename = <span class="stringliteral">&quot;../../../../../../../../../../../etc/passwd&quot;</span>, readonly = (size_t)<span class="charliteral">&#39;1&#39;</span> }
        }
},
{ <span class="keyword">class </span>=&gt; &quot;data/split&quot;                         },
{ <span class="keyword">class </span>=&gt; &quot;data/regexp&quot;, regexp = <span class="stringliteral">&quot;/bin/false&quot;</span> },
{ <span class="keyword">class </span>=&gt; &quot;request/switch&quot;, rules = {
        {
                request = {
                        marker = (uint_t)<span class="charliteral">&#39;1&#39;</span>
                },
                backend = {
                        { <span class="keyword">class </span>= &quot;io/stdout&quot; }
                }
        }
}}
</pre></div><p><a class="el" href="group__mod__backend__file.html">storage/file</a> open file for reading only (../ hack is ugly, will fix someday). <a class="el" href="group__mod__backend__split.html">data/split</a> split it in lines. <a class="el" href="group__mod__backend__regexp.html">data/regexp</a> matches /bin/false aganist input line and pass to <a class="el" href="group__mod__backend__switch.html">request/switch</a>. It lookup for default marker value and if find - pass to <a class="el" href="group__mod__backend__stdout.html">io/stdout</a>. Whole thing works like simple grep, a bit silly but read further. What if you want more regexps? No problem: </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;data/transfer&quot;,
        source = {
                { <span class="keyword">class </span>=&gt; &quot;file&quot;, filename = <span class="stringliteral">&quot;../../../../../../../../../../../etc/passwd&quot;</span>, readonly = (size_t)<span class="charliteral">&#39;1&#39;</span> }
        },
        destination = {
                { <span class="keyword">class </span>=&gt; &quot;data/split&quot;                             },
                { <span class="keyword">class </span>=&gt; &quot;data/regexp&quot;, regexp = <span class="stringliteral">&quot;/bin/false&quot;</span>     },
                { <span class="keyword">class </span>=&gt; &quot;data/regexp&quot;, regexp = <span class="stringliteral">&quot;/sbin/nologin&quot;</span>  },
                { <span class="keyword">class </span>=&gt; &quot;request/switch&quot;, rules = {
                        {
                                request = {
                                        marker = (uint_t)<span class="charliteral">&#39;1&#39;</span>
                                },
                                backend = {
                                        { <span class="keyword">class </span>= &quot;io/stdout&quot; }
                                }
                        }
                }}
        }
}
</pre></div><p>As regexp set same marker this construction works like OR. For AND use different markers and combine them in switch rule like so: </p>
<div class="fragment"><pre class="fragment">      ...
      { <span class="keyword">class </span>=&gt; &quot;data/regexp&quot;, regexp = <span class="stringliteral">&quot;/bin&quot;</span>,  marker = <span class="stringliteral">&quot;key1&quot;</span>  }, 
      { <span class="keyword">class </span>=&gt; &quot;data/regexp&quot;, regexp = <span class="stringliteral">&quot;/home&quot;</span>, marker = <span class="stringliteral">&quot;key2&quot;</span>  }, 
      { <span class="keyword">class </span>=&gt; &quot;request/switch&quot;, rules = {
          {  
              request = {
                      key1 = (uint_t)<span class="charliteral">&#39;1&#39;</span>,
                      key2 = (uint_t)<span class="charliteral">&#39;1&#39;</span>
              },
      ...
</pre></div><p> Because <a class="el" href="group__mod__backend__switch.html">request/switch</a> don't care what in your rule's request you could first check for such AND condition, if it not matches check for only one marker, or for another, or for both. And for each rule you can supply different backend with any action.</p>
<p>You can have any number of regexps. And even more: you can define one regexp for pre-matching and it's result will define which set of actions (including another regexps) it will go through. You could write matching lines in one file, and simultaneously write non-matching to another file. If you pick up <a class="el" href="group__mod__backend__fuse.html">io/fuse</a> for input and run frozen as daemon - this predefined complex pipe will process any data at any time. Grep can't do that. </p>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 26 2011 22:03:28 for frozen by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4</small></address>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7806052-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body>
</html>
