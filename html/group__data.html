<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>frozen: Data</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">frozen&#160;<span id="projectnumber">1.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">Data</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hash__t.html">hash_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__backend__t.html">backend_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__t.html">buffer_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__counter__t.html">counter_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dataptr__t.html">dataptr_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__datatype__t.html">datatype_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__default__t.html">default_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__emitter__t.html">emitter_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fd__t.html">fd_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__format__t.html">format_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hash__key__t.html">hash_key_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__io__t.html">io_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__random__t.html">random_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__raw__t.html">raw_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slice__t.html">slice_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__slider__t.html">slider_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string__t.html">string_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__int16__t.html">int16_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__int32__t.html">int32_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__int64__t.html">int64_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__int8__t.html">int8_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intmax__t.html">intmax_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__off__t.html">off_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__size__t.html">size_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uint16__t.html">uint16_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uint32__t.html">uint32_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uint64__t.html">uint64_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uint8__t.html">uint8_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uintmax__t.html">uintmax_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__void__t.html">void_t</a></td></tr>
</table>


<h3><a class="anchor" id="data_overview"></a>Data overview</h3><div class="textblock"><p>Frozen tries to use native C data representation where it possible. Native types is uintmax_t (TYPE_UINTT), char * (TYPE_STRING), own structures such as <a class="el" href="structhash__t.html" title="Hash item.">hash_t</a>, <a class="el" href="structbackend__t.html" title="Backend structure.">backend_t</a>, datatype_t and so on.</p>
<p>To keep data type consistensy and generalize data processing "data holder" was introduced. This is simple structure <a class="el" href="structdata__t.html" title="Data holder.">data_t</a> which consist of data type field and pointer to data. Data api accept only data wrapped in such holder. Wrapping can be achieved directly in user function, without unnessesery calls, so this have low overhead.</p>
<p>Data api, as backend api, receive data holder and request with specified action inside. If this data have correct handlers for action api performs it. There are many standard actions defined, for example, ACTION_READ, _WRITE, _COPY, _ALLOC, _FREE, _COMPARE, _CONVERT_TO, _CONVERT_FROM and so on.</p>
<p>Data api use same structures and actions as API_FAST, so it will be easy to pass request, arrived to backend, to data. See <a class="el" href="group__api.html">API_FAST</a> </p>
</div>

<h3><a class="anchor" id="data_default"></a>Default data type (default_t)</h3><div class="textblock"><p>This data type is special. Then you create new data type it can inherit some common functions. For example, data type TYPE_RAWT internally consist of simple structure with pointer to actual data. There is no reasons to copy-and-paste such code as _READ, _WRITE routines. Also, this problem can be solved with complex inheritance support, which in turn rise complexity of whole program and can introduce more problems in future than help. So, default_t was introduced. It consist of safe functions to work with memory chunks.</p>
<p>To use this data type in your data handlers, you need to supply several helper routines. This includes ACTION_PHYSICALLEN, ACTION_LOGICALLEN and ACTION_GETDATAPTR. They describe properties of memory chunk you want to process. Default_t itself know nothing about data it process. You also can't create clean default_t data, routines will return errors. </p>
</div>

<h3><a class="anchor" id="data_memorymanagment"></a>Memory managment</h3><div class="textblock"><p>Almost every data can exist in three variations: within data section, within stack and within heap. Data api itself should not resist any of this representation. However, it is worth to mention, than some of data actions can produce only allocated data. This includes: ACTION_COPY, ACTION_ALLOC, ACTION_CONVERT_FROM and can be more. After calling this actions user is responsible to free allocated data.</p>
<p>Policy of data action handler should be following: </p>
<ul>
<li>if user supply empty data handler (i.e. with NULL pointer to data) api should silently allocate data and return result </li>
<li>if user supply non-empty data - try to write to it, if this fails - return error.</li>
</ul>
<p>Data handler should be ready to any: sectioned, stacked and heaped data. Never realloc or free data if you not 100% sure it was allocated (keep flag or something).</p>
<p>Same policy applied to data created and processed by backends: backend responsible to free allocated data, supply valid or empty data for request. </p>
</div>

<h3><a class="anchor" id="data_conversion"></a>Data conversion</h3><div class="textblock"><p>Some of frozen api, for example hash_data_copy, can convert values from hash to desired type. It possible if data represent plain value (like integers), or plain pointer (as backend). For rest of data types, which require allocation, this process can't be automated, as requires free of allocated resources. For those data types you should manually call data_convert macro, or plain data_query with proper request.</p>
<p>All integer data can be converted in any other integer type. Buffer or string, containing human representation of integer, can also be converted in clean integer type. String with backend name can be converted to this backend pointer, hash with backend config can also be converted to new backend, and so on.</p>
<p>This ability also useful to avoid unnesessery data copying from place to place. For example, ipc_shmem backend use shared memory to send data to another process. If there was no conversion, it would require buffer with already packed data, which would be copied to shared memory. And, of course, special packing backend. Instead of that, ipc_shmem take any input and convert it directly to shared memory. </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Dec 2 2011 14:31:42 for frozen by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
