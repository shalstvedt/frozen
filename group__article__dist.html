<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="keywords" content="frozen, data, processing, big data, daemon, fast, flexible"/>
<title>Building distributed data processing pipeline | frozen - flexible data processing daemon</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">frozen
   &#160;<span id="projectnumber">1.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Building distributed data processing pipeline</div>  </div>
<div class="ingroups"><a class="el" href="group__articles.html">Articles</a></div></div><!--header-->
<div class="contents">
<p>Then we try to process huge amount of data it nearly always results in building complex and hardly maintainable systems with all sort of tools in it: starting with split + rsync files between computers and ending with hardcore scripts on all possible languages. Recently some problems were solved, including appearance of ZeroMQ which really helps. But you still can not jump on to problem and solve it quickly, it always require to spend some time to prepare, build blocks and only then solve actual problems. Frozen try to fill this gap and provide these blocks. Lets see how we can build something distributed.</p>
<h2><a class="anchor" id="goal"></a>
Goal</h2>
<p>Lets took something simple and move to more complex things. Assume we have huge file with data represented as lines in it. We want to split it in several groups and for each group we have own special handler.</p>
<h2><a class="anchor" id="step1"></a>
Step 1: read data</h2>
<p>To read data we use following config: </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>= &quot;thread&quot; },
{ <span class="keyword">class </span>= &quot;query&quot;, data = (file_t){ filename = <span class="stringliteral">&quot;/var/log/messages&quot;</span>, readonly = (uint_t)<span class="stringliteral">&quot;1&quot;</span> }, request = {
        action      = (action_t)<span class="stringliteral">&quot;transfer&quot;</span>,
        destination = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                
                <span class="comment">// split file chunks to lines</span>
                { <span class="keyword">class </span>= &quot;split&quot; },
                
                <span class="comment">// send to next process</span>
                { <span class="keyword">class </span>= &quot;modules/zeromq&quot;, convert = (uint_t)<span class="stringliteral">&quot;1&quot;</span>, socket = (zeromq_t){
                        type    = <span class="stringliteral">&quot;push&quot;</span>,
                        connect = <span class="stringliteral">&quot;tcp://127.0.0.1:8800&quot;</span>
                }},
                { <span class="keyword">class </span>= &quot;end&quot; }
        }
}},
{ <span class="keyword">class </span>= &quot;kill&quot; }
</pre></div><p>We just read data from file, next we split it in lines and send using zeromq to workers pool. We do not bother with doing it fast right here because we do not need to. If you have huge data, you possibly have huge cluster to process it, and very likely you have distributed fs on it. Every cluster configuration have it's own advantages and disadvantages. Maybe you have several data storage servers and they are very good at reading speed, but maybe you have common hardware with low read speed on hdd. In any case you should consider best approach for your cluster and use it. We can start as many readers with as many files as we want, because zeromq allow us to join this flows to be merged into one.</p>
<h2><a class="anchor" id="step2"></a>
Step 2: categorize data</h2>
<p>At first, we create dummy worker, it only print our data and we ensure that everything is ok. </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>= &quot;thread&quot;, loop = (uint_t)<span class="stringliteral">&quot;1&quot;</span> },

<span class="comment">// get message</span>
{ <span class="keyword">class </span>= &quot;modules/zeromq&quot;, socket = (zeromq_t){
        type    = <span class="stringliteral">&quot;pull&quot;</span>,
        bind    = <span class="stringliteral">&quot;tcp://127.0.0.1:8800&quot;</span>
}},

<span class="comment">// print to console</span>
{ <span class="keyword">class </span>= &quot;query&quot;, data = (<a class="code" href="structfd__t.html">fd_t</a>)<span class="stringliteral">&quot;stdout&quot;</span>, request = { action = (action_t)<span class="stringliteral">&quot;write&quot;</span>, buffer = (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;buffer&quot;</span> } },

<span class="comment">// send to next process</span>
{ <span class="keyword">class </span>= &quot;modules/zeromq&quot;, socket = (zeromq_t){
        type    = <span class="stringliteral">&quot;push&quot;</span>,
        connect = <span class="stringliteral">&quot;tcp://127.0.0.1:8801&quot;</span>
}},
{ <span class="keyword">class </span>= &quot;end&quot; }
</pre></div><p>Next step is to decide - which data where to go. Lets to in straightforward for now with <a class="el" href="group__mod__machine__regexp.html">data/regexp</a>. </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>= &quot;thread&quot;, loop = (uint_t)<span class="stringliteral">&quot;1&quot;</span> },

<span class="comment">// get message</span>
{ <span class="keyword">class </span>= &quot;modules/zeromq&quot;, socket = (zeromq_t){
        type    = <span class="stringliteral">&quot;pull&quot;</span>,
        bind    = <span class="stringliteral">&quot;tcp://127.0.0.1:8800&quot;</span>
}},

<span class="comment">// process only messages with &quot;dhcp&quot; in it</span>
{ <span class="keyword">class </span>= &quot;regexp&quot;, regexp = <span class="stringliteral">&quot;dhcp&quot;</span> },
{ <span class="keyword">class </span>= &quot;switch&quot;, rules = {
        {
                request = { marker = (uint_t)<span class="stringliteral">&quot;1&quot;</span> },
                machine = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                        
                        <span class="comment">// print to console</span>
                        { <span class="keyword">class </span>= &quot;query&quot;, data = (<a class="code" href="structfd__t.html">fd_t</a>)<span class="stringliteral">&quot;stdout&quot;</span>, request = { action = (action_t)<span class="stringliteral">&quot;write&quot;</span>, buffer = (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;buffer&quot;</span> } },
                        
                        <span class="comment">// send to next process</span>
                        { <span class="keyword">class </span>= &quot;modules/zeromq&quot;, socket = (zeromq_t){
                                type    = <span class="stringliteral">&quot;push&quot;</span>,
                                connect = <span class="stringliteral">&quot;tcp://127.0.0.1:8801&quot;</span>
                        }},
                        { <span class="keyword">class </span>= &quot;end&quot; }
                }
        }
}},

{ <span class="keyword">class </span>= &quot;end&quot; }
</pre></div><p>Here we grep data with "dhcp" in it and send to another process. See both <a class="el" href="group__mod__machine__regexp.html">data/regexp</a>, <a class="el" href="group__mod__machine__switch.html">request/switch</a> and <a class="el" href="group__tutorial__common.html">Tutorial: most used modules</a> for more complex examples.</p>
<h2><a class="anchor" id="step3"></a>
Step 3: save results</h2>
<p>After processing we want to save results, lets save it to simple file. </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>= &quot;thread&quot;, loop = (uint_t)<span class="stringliteral">&quot;1&quot;</span> },
{ <span class="keyword">class </span>= &quot;modules/zeromq&quot;, socket = (zeromq_t){
        type = <span class="stringliteral">&quot;pull&quot;</span>,
        bind = <span class="stringliteral">&quot;tcp://127.0.0.1:8801&quot;</span>
}},
{ <span class="keyword">class </span>= &quot;query&quot;,
        data = (<a class="code" href="structslider__t.html">slider_t</a>){
                data = (file_t){ filename = <span class="stringliteral">&quot;result.dat&quot;</span> }
        },
        request = {
                action = (action_t)<span class="stringliteral">&quot;write&quot;</span>,
                buffer = (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;buffer&quot;</span>
        }
},
{ <span class="keyword">class </span>= &quot;end&quot; }
</pre></div><h2><a class="anchor" id="testing"></a>
Testing</h2>
<p>As you can notice, all zeromq adresses is local, so we definitely need to start it on local machine, but it will work on cluster when you change addresses to correct one.</p>
<div class="fragment"><pre class="fragment">   $ frozend -c examples/article_dist_destination.m4 
</pre></div> <div class="fragment"><pre class="fragment">   $ frozend -c examples/article_dist_worker_reg.m4
</pre></div> <div class="fragment"><pre class="fragment">   $ frozend -c examples/article_dist_source.m4 
</pre></div><p>Then source finish reading, we could see in worker console grepped data and destination worker wrote data to file too.</p>
<h2><a class="anchor" id="improve"></a>
Possible improvements</h2>
<p>That was easy, but not so useful. Here how we can improve things:</p>
<ul>
<li>
Problem: hardcoded addresses. Solutions: <ul>
<li>
As you can notice config file is m4 script, you can make include file with addresses, or join all files into one and use ifdef and roles supplied from command line </li>
<li>
You can pass zeromq socket to remote machine. And remote machine use this socket to return data, or send it to another stage </li>
</ul>
</li>
<li>
Problem: hardcoded categorization and complex config file. Solutions: <ul>
<li>
It is still m4 file - use define() to describe common categorization rule, and just put MY_RULE(`dhcp', `tcp://somehost:12345') as many as you need. </li>
<li>
You can pass parameters and rules for worker at same time with data. Don't know there it can be used, but you can. </li>
</ul>
</li>
<li>
Problem: not flexible processing. Solutions: if you have some very complex processing requirements, write module by yourself - it is just zeromq messages with clean data flowing around. Pick your favorite language and process as you like, return to frozen if need. </li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated for frozen by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a></small></address>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7806052-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body>
</html>
