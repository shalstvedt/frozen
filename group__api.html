<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="keywords" content="frozen, data, processing, big data, daemon, fast, flexible"/>
<title>Frozen - flexible data processing daemon</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">frozen
   &#160;<span id="projectnumber">1.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Api</div>  </div>
</div>
<div class="contents">


<h3><a class="anchor" id="api_overview"></a>Api overview</h3><div class="textblock"><p>Frozen currently have several api. One of the most important is API_HASH and API_FAST. They represent two different approaches to sending requests.</p>
<p>Then user want api he expect that api would be customizable and very fast. Both of these characteristics hardly can be implemented in one api set. So, in frozen, we introduce two api sets: API_HASH - for custom requests, and API_FAST for very fast requests.</p>
<p>Despite of kind of api used, every api deals with requests. Request is a set of key-value pairs.</p>
<p>Each request have "action" key to tell machine what to do with data. Some machines don't require action for request, so initial user request can have no action, but for further processing one of machines have to define it. </p>
</div>

<h3><a class="anchor" id="api_hash"></a>API_HASH</h3><div class="textblock"><p>Hash api deals with specially structured key-value pairs. From the C point of view they are arrays of <a class="el" href="structhash__t.html" title="Hash item.">hash_t</a> structure. To declare new hash you could write: </p>
<div class="fragment"><pre class="fragment">      <a class="code" href="structhash__t.html" title="Hash item.">hash_t</a> new_hash[] = {
         { HK(key), DATA_UINTT(100) },
         hash_end
      };
      machine_query(machine, new_hash);
</pre></div><p> This hash declare one parameter named "key" with value of 100.</p>
<p>Such structures used to describe user request and process it. It can hold any amount of parameters with any data type and any value. Also, data value isn't copied to hash, hash only hold pointer to data. So, unnessesary copying form place to place avoided.</p>
<p>If hash defined within function such declaration converted to several "mov" and "lea" assembly command, which write hash in current stack frame. This can be processed very fast, because of lack of shoped computation and hopefuly with help of caches.</p>
<p>Staticly declared hashes already datad in usable form, so no overhead here.</p>
<p>Hash can contain inline hashes, can contain embeded hashes and so on. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>hashes</dd></dl>
<p>In conclusion, advantages of this api type: </p>
<ul>
<li>Any number and order of parameters </li>
<li>Any number of optional and required parameters, again, in any order </li>
<li>Data not copied from user's buffer </li>
<li>Fast "allocation" and assignment</li>
</ul>
<p>Disadvantages: </p>
<ul>
<li>Very greedy to stack space. (However stack space is already allocated and used, so why not?) </li>
<li>Key find is slow. This done by incremental search througth all parameters. </li>
</ul>
</div>

<h3><a class="anchor" id="api_fast"></a>API_FAST</h3><div class="textblock"><p>As opposite to API_HASH, API_FAST was introduced. Main reason is speed - hash api is too slow for key find. Then some "index" machines deals with "memory" each user request produce hundreds of requests to "memory" machine, and every request to "memory" have at least 3 parameters (offset, size, buffer). So, hash_find api gets very busy and callgrind isn't very happy with that.</p>
<p>However, this situation is simple to solve. We know how many parameters we want to pass, and we have no optional parameters. Simpliest solution is pack all parameters in order known to both machines. In C world this can be perfectly done by defining a struct. So, we use them for fast api.</p>
<p>Each action have own structure, where data defined in specified order. As bonus, you can have own optional paramenters by redefining structure.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment">       <a class="code" href="structfastcall__io.html">fastcall_read</a> r_read = {
          { 5, ACTION_READ },         <span class="comment">// { number of all arguments, action }</span>
          0,                          <span class="comment">// .offset</span>
          &amp;buffer,                    <span class="comment">// .buffer</span>
          100                         <span class="comment">// .buffer_size</span>
       };
       machine_fast_query(machine, &amp;r_read);
</pre></div><p>Advantages: </p>
<ul>
<li>It is very likely that whole structure can fit in processor cache, so: </li>
<li>Incredibly fast parameter search </li>
<li>Still can have some optional parameters</li>
</ul>
<p>Disadvantages: </p>
<ul>
<li>If you want change request action, you should copy old values and fill new structure </li>
<li>If you want to change value of request and keep old value, you should keep value, or make new structure and fill it </li>
<li>No freedom in parameter defines </li>
</ul>
</div>

<h3><a class="anchor" id="api_crwd"></a>API_CRWD</h3><div class="textblock"><p>Api crwd is same as api hash, but all requests splitted to flow into different handlers. This api would be transformed in same api as used in data processing. Don't use it for a while. </p>
</div>

<h3><a class="anchor" id="api_downgrade"></a>Downgrading</h3><div class="textblock"><p>Currenly machine code have support for so called "request downgrading". This process occurs then some API_FAST-capable machine pass request to API_FAST-notcapable machine. So, this code creates new hash request and fill it with parameters from fast request.</p>
<p>This is very painful process. At first, all optional parameters is lost. Second, this is overhead in any case. Third, all further processing is done by hash apis. There is no such process as "upgrading" and never be.</p>
<p>As developer, try avoid this. As end user, you can ignore it. </p>
</div>

<h3><a class="anchor" id="api_newmachine"></a>Recomendations for new machines</h3><div class="textblock"><p>If you write new machine you have to choose which api to implement.</p>
<p>If machine provide access to very fast things, such as memory - API_FAST is top priority. Common things, such as files, directories have to implement both API_HASH and API_FAST. Unusual things, and data processing can implement only API_HASH. </p>
</div></div>


<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 21 2012 13:37:12 for frozen by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1</small></address>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7806052-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body>
</html>
