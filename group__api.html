<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="keywords" content="frozen, data, processing, big data, daemon, fast, flexible"/>
<title>Api | frozen - flexible data processing daemon</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">frozen
   &#160;<span id="projectnumber">1.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">Api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__api__core"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api__core.html">Core api set</a></td></tr>
<tr class="memitem:group__api__storage"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api__storage.html">Basic storage api set</a></td></tr>
<tr class="memitem:group__api__arith"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api__arith.html">Basic arithmetic api set</a></td></tr>
<tr class="memitem:group__api__compare"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api__compare.html">Compare api set</a></td></tr>
<tr class="memitem:group__api__items"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api__items.html">Items api set</a></td></tr>
<tr class="memitem:group__api__view"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__api__view.html">Data view api set</a></td></tr>
</table>


<h3><a class="anchor" id="api_overview"></a>Api overview</h3><div class="textblock">Frozen currently have several api. One of the most important is API_HASH and API_FAST. They represent two different approaches to sending requests.Then user want api he expect that api would be customizable and very fast. Both of these characteristics hardly can be implemented in one api set. So, in frozen, we introduce two api sets: API_HASH - for custom requests, and API_FAST for very fast requests.Despite of kind of api used, every api deals with requests. Request is a set of key-value pairs.Each request have "action" key to tell machine what to do with data. Some machines don't require action for request, so initial user request can have no action, but for further processing one of machines have to define it. </div>

<h3><a class="anchor" id="api_hash"></a>API_HASH</h3><div class="textblock">Hash api deals with specially structured key-value pairs. From the C point of view they are arrays of <a class="el" href="structhash__t.html" title="Hash item.">hash_t</a> structure. To declare new hash you could write: </p>
<div class="fragment"><pre class="fragment">      <a class="code" href="structhash__t.html" title="Hash item.">hash_t</a> new_hash[] = {
         { HK(key), DATA_UINTT(100) },
         hash_end
      };
      machine_query(machine, new_hash);
</pre></div><p> This hash declare one parameter named "key" with value of 100.Such structures used to describe user request and process it. It can hold any amount of parameters with any data type and any value. Also, data value isn't copied to hash, hash only hold pointer to data. So, unnecessary copying form place to place avoided.If hash defined within function such declaration converted to several "mov" and "lea" assembly command, which write hash in current stack frame. This can be processed very fast, because of lack of shoped computation and hopefully with help of caches.Statically declared hashes already stored in usable form, so no overhead here.Hash can contain inline hashes, can contain embedded hashes and so on. </p>
<dl class="section see"><dt>See also:</dt><dd>hashes</dd></dl>
<p>In conclusion, advantages of this api type: </p>
<ul>
<li>Any number and order of parameters </li>
<li>Any number of optional and required parameters </li>
<li>Data not copied from user's buffer </li>
<li>Fast "allocation" and assignment</li>
</ul>
<p>Disadvantages: </p>
<ul>
<li>Very greedy to stack space. (However stack space is already allocated and used, so why not?) </li>
<li>Key find is slow. This done by incremental search through all parameters. </li>
</ul>
</div>

<h3><a class="anchor" id="api_fast"></a>API_FAST</h3><div class="textblock">As opposite to API_HASH, API_FAST was introduced. Main reason is speed - hash api is too slow for key find. Then some "index" machines deals with "memory" each user request produce hundreds of requests to "memory" machine, and every request to "memory" have at least 3 parameters (offset, size, buffer). So, hash_find api gets very busy and callgrind isn't very happy with that.However, this situation is simple to solve. We know how many parameters we want to pass, and we have no optional parameters. Simplest solution is pack all parameters in order known to both machines. In C world this can be perfectly done by defining a struct. So, we use them for fast api.Each action have own structure, where data defined in specified order. As bonus, you can have own optional parameters by redefining structure.Example: </p>
<div class="fragment"><pre class="fragment">       <a class="code" href="structfastcall__io.html">fastcall_read</a> r_read = {
          { 5, ACTION_READ },         <span class="comment">// { number of all arguments, action }</span>
          0,                          <span class="comment">// .offset</span>
          &amp;buffer,                    <span class="comment">// .buffer</span>
          100                         <span class="comment">// .buffer_size</span>
       };
       data_query(data, &amp;r_read);
</pre></div>Advantages: </p>
<ul>
<li>It is very likely that whole structure can fit in processor cache, so: </li>
<li>Incredibly fast parameter search </li>
<li>Still can have some optional parameters</li>
</ul>
<p>Disadvantages: </p>
<ul>
<li>If you want change request action, you should copy old values and fill new structure </li>
<li>If you want to change value of request and keep old value, you should keep value, or make new structure and fill it </li>
<li>No freedom in parameter defines </li>
</ul>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated for frozen by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a></small></address>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7806052-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body>
</html>
