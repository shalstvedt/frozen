<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="keywords" content="frozen, data, processing, big data, daemon, fast, flexible"/>
<title>Frozen - flexible data processing daemon</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">frozen
   &#160;<span id="projectnumber">1.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial: most used modules</div>  </div>
<div class="ingroups"><a class="el" href="group__tutorial.html">Tutorials</a></div></div>
<div class="contents">
<h2><a class="anchor" id="tutorial_basics_input"></a>
Input</h2>
<p><em>Stdin</em> </p>
<p>To have anything to be parsed it should be somehow passed in machine. Frozen have different ways in input data, most simple one is console. <a class="el" href="group__mod__machine__stdin.html">io/stdin</a> used to get data from stdin. And because stdin module is passive, <a class="el" href="group__mod__machine__query.html">data/query</a> with <a class="el" href="group__mod__machine__thread.html">daemon/thread</a> used to activly transfer data from one machine shop to another. In this case destination is <a class="el" href="group__mod__machine__stdout.html">io/stdout</a> used. For more about outputs read next chapter.</p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;emitter&quot;, request = {
        request = {
                action      = (action_t)<span class="stringliteral">&quot;transfer&quot;</span>,
                source      = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                        { <span class="keyword">class </span>=&gt; &quot;io/stdin&quot; }
                },
                destination = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                        { <span class="keyword">class </span>=&gt; &quot;io/stdout&quot;  }
                }
        },
        machine = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                { <span class="keyword">class </span>= &quot;data/query&quot;, data = (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;source&quot;</span> },
                { <span class="keyword">class </span>= &quot;end&quot; }
        }
}},
{ <span class="keyword">class </span>= &quot;kill&quot; }
</pre></div><p><em>Fuse</em> </p>
<p>Next way is <a class="el" href="group__mod__machine__fuse.html">io/fuse</a> machine. It create filesystem using fuse and pass all read and writes to user defined machines. Sample configuration can look like so:</p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>= &quot;fuse&quot;, mountpoint = <span class="stringliteral">&quot;/home/test/&quot;</span>, items = {
        { path = <span class="stringliteral">&quot;/one&quot;</span>, machine = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                { <span class="keyword">class </span>= &quot;io/stdout&quot; }
        }}
}}
</pre></div><p>This creates file system in /home/test folder, which contain file named "one" and every write request to this file will result in console output. Use "echo 'hello' &gt;&gt; /home/test/one" or similar to test it.</p>
<p><em>Emitter</em> </p>
<p>One more way to input is describe machine which send requests you want. One of such machines is <a class="el" href="group__mod__machine__emitter.html">request/emitter</a>. Example: </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;request/emitter&quot;,
        request = {
                request = { buffer = <span class="stringliteral">&quot;Hello, world!\n&quot;</span> },
                machine = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                        { <span class="keyword">class </span>=&gt; &quot;io/stdout&quot; }
                }
        }
},
{ <span class="keyword">class </span>=&gt; &quot;daemon/kill&quot; }
</pre></div><p><em>HTTP</em> </p>
<p>Another way is different modules, for example go_http. It create simple web server and pass request to user's machines. </p>
<div class="fragment"><pre class="fragment"></pre></div><p><em>File</em> </p>
<p>You could read data from file and use it as input data. Construction is same as for stdin. </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;emitter&quot;, request = {
        request = {
                action      = (action_t)<span class="stringliteral">&quot;transfer&quot;</span>,
                source      = (<a class="code" href="structfile__t.html">file_t</a>){ filename = <span class="stringliteral">&quot;TODO&quot;</span>  },
                destination = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                        { <span class="keyword">class </span>=&gt; &quot;io/stdout&quot;  }
                }
        },
        machine = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                { <span class="keyword">class </span>= &quot;data/query&quot;, data = (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;source&quot;</span> },
                { <span class="keyword">class </span>= &quot;end&quot; }
        }
}},
{ <span class="keyword">class </span>= &quot;kill&quot; }
</pre></div><h2><a class="anchor" id="tutorial_basics_output"></a>
Output</h2>
<p><em>Debugging</em> </p>
<p>To debug request flow you can use <a class="el" href="group__mod__machine__debug.html">request/debug</a> machine. It print line in stderr on request arrival, and optionally on request end. Also it can show request content. Example: </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;emitter&quot;, request = {
        request = {
                action      = (action_t)<span class="stringliteral">&quot;transfer&quot;</span>,
                source      = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                        { <span class="keyword">class </span>=&gt; &quot;io/stdin&quot; }
                },
                destination = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                        { <span class="keyword">class </span>=&gt; &quot;request/debug&quot;  }
                }
        },
        machine = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                { <span class="keyword">class </span>= &quot;data/query&quot;, data = (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;source&quot;</span> },
                { <span class="keyword">class </span>= &quot;end&quot; }
        }
}},
{ <span class="keyword">class </span>= &quot;kill&quot; }
</pre></div><p><em>Stdout</em> </p>
<p>This could be done by <a class="el" href="group__mod__machine__stdout.html">io/stdout</a>. It print buffer in console stdout. For stderr - use <a class="el" href="group__mod__machine__stderr.html">io/stderr</a>. </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;emitter&quot;, request = {
        request = {
                action      = (action_t)<span class="stringliteral">&quot;transfer&quot;</span>,
                source      = (<a class="code" href="structfile__t.html">file_t</a>){ filename = <span class="stringliteral">&quot;TODO&quot;</span>  },
                destination = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                        { <span class="keyword">class </span>=&gt; &quot;io/stdout&quot;  }
                }
        },
        machine = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                { <span class="keyword">class </span>= &quot;data/query&quot;, data = (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;source&quot;</span> },
                { <span class="keyword">class </span>= &quot;end&quot; }
        }
}},
{ <span class="keyword">class </span>= &quot;kill&quot; }
</pre></div><p><em>File</em> </p>
<p>Write data to file with mod_machine_file machine. Example: </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;emitter&quot;, request = {
        request = {
                action      = (action_t)<span class="stringliteral">&quot;transfer&quot;</span>,
                source      = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                        { <span class="keyword">class </span>=&gt; &quot;io/stdin&quot; }
                },
                destination = (<a class="code" href="structfile__t.html">file_t</a>){ filename = <span class="stringliteral">&quot;example_out_file.dat&quot;</span> }
        },
        machine = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                { <span class="keyword">class </span>= &quot;data/query&quot;, data = (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;source&quot;</span> }
        }
}},
{ <span class="keyword">class </span>= &quot;kill&quot; }
</pre></div><h2><a class="anchor" id="tutorial_basics_processing"></a>
Processing</h2>
<p><em>Split</em> </p>
<p>It is very common to process data line-by-line, especially in UNIX world, but for performance reasons frozen by default don't split incoming data on lines. If you want lines you should use <a class="el" href="group__mod__machine__split.html">data/split</a> machine. By default it split input exactly by <br/>
 which mean end of line.</p>
<p><em>Regexp</em> </p>
<p>To match some input for pattern you can use <a class="el" href="group__mod__machine__regexp.html">data/regexp</a>. It add special marker to current request if data match defined pattern.</p>
<p><em>Conditions</em> </p>
<p>As we have some markers, where got to be some condition. <a class="el" href="group__mod__machine__switch.html">request/switch</a> control request flow using conditions. Because flow could be redirected in any other machine shop you could do anything with such request or enviroment, for example terminate request, return success or error, write this to logger, trigger some action and so on.</p>
<h2><a class="anchor" id="tutorial_basics_combine"></a>
Combining all together</h2>
<p>As we know some of processing and input machines we could combine it in something useful. For example, you want to know which users have /bin/false shell. Configuration will look like following: </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;emitter&quot;, request = {
        request = {
                action      = (action_t)<span class="stringliteral">&quot;transfer&quot;</span>,
                source      = (<a class="code" href="structfile__t.html">file_t</a>){ filename = <span class="stringliteral">&quot;/etc/passwd&quot;</span>, readonly = (size_t)<span class="charliteral">&#39;1&#39;</span> },
                destination = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                        { <span class="keyword">class </span>=&gt; &quot;data/split&quot;                         },
                        { <span class="keyword">class </span>=&gt; &quot;data/regexp&quot;, regexp = <span class="stringliteral">&quot;/bin/false&quot;</span> },
                        { <span class="keyword">class </span>=&gt; &quot;request/switch&quot;, rules = {
                                {
                                        request = {
                                                marker = (uint_t)<span class="charliteral">&#39;1&#39;</span>
                                        },
                                        machine = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                                                { <span class="keyword">class </span>= &quot;io/stdout&quot; }
                                        }
                                }
                        }},
                        { <span class="keyword">class </span>= &quot;end&quot; }
                }
        },
        machine = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                { <span class="keyword">class </span>= &quot;data/query&quot;, data = (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;source&quot;</span> },
                { <span class="keyword">class </span>= &quot;end&quot; }
        }
}},
{ <span class="keyword">class </span>= &quot;kill&quot; }
</pre></div><p>mod_machine_file open file for reading only. <a class="el" href="group__mod__machine__split.html">data/split</a> split it in lines. <a class="el" href="group__mod__machine__regexp.html">data/regexp</a> matches /bin/false aganist input line and pass to <a class="el" href="group__mod__machine__switch.html">request/switch</a>. It lookup for default marker value and if find - pass to <a class="el" href="group__mod__machine__stdout.html">io/stdout</a>. Whole thing works like simple grep, a bit silly but read further. What if you want more regexps? No problem: </p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;emitter&quot;, request = {
        request = {
                action      = (action_t)<span class="stringliteral">&quot;transfer&quot;</span>,
                source      = (<a class="code" href="structfile__t.html">file_t</a>){ filename = <span class="stringliteral">&quot;/etc/passwd&quot;</span>, readonly = (size_t)<span class="charliteral">&#39;1&#39;</span> },
                destination = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                        { <span class="keyword">class </span>=&gt; &quot;data/split&quot;                             },
                        { <span class="keyword">class </span>=&gt; &quot;data/regexp&quot;, regexp = <span class="stringliteral">&quot;/bin/false&quot;</span>     },
                        { <span class="keyword">class </span>=&gt; &quot;data/regexp&quot;, regexp = <span class="stringliteral">&quot;/sbin/nologin&quot;</span>  },
                        { <span class="keyword">class </span>=&gt; &quot;request/switch&quot;, rules = {
                                {
                                        request = {
                                                marker = (uint_t)<span class="charliteral">&#39;1&#39;</span>
                                        },
                                        machine = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                                                { <span class="keyword">class </span>= &quot;io/stdout&quot; }
                                        }
                                }
                        }},
                        { <span class="keyword">class </span>= &quot;end&quot; }
                }
        },
        machine = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                { <span class="keyword">class </span>= &quot;data/query&quot;, data = (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;source&quot;</span> },
                { <span class="keyword">class </span>= &quot;end&quot; }
        }
}},
{ <span class="keyword">class </span>= &quot;kill&quot; }
</pre></div><p>As regexp set same marker this construction works like OR. For AND use different markers and combine them in switch rule like so: </p>
<div class="fragment"><pre class="fragment">      ...
      { <span class="keyword">class </span>=&gt; &quot;data/regexp&quot;, regexp = <span class="stringliteral">&quot;/bin&quot;</span>,  marker = <span class="stringliteral">&quot;key1&quot;</span>  }, 
      { <span class="keyword">class </span>=&gt; &quot;data/regexp&quot;, regexp = <span class="stringliteral">&quot;/home&quot;</span>, marker = <span class="stringliteral">&quot;key2&quot;</span>  }, 
      { <span class="keyword">class </span>=&gt; &quot;request/switch&quot;, rules = {
          {  
              request = {
                      key1 = (uint_t)<span class="charliteral">&#39;1&#39;</span>,
                      key2 = (uint_t)<span class="charliteral">&#39;1&#39;</span>
              },
      ...
</pre></div><p> Because <a class="el" href="group__mod__machine__switch.html">request/switch</a> don't care what in your rule's request you could first check for such AND condition, if it not matches check for only one marker, or for another, or for both. And for each rule you can supply different machine with any action.</p>
<p>You can have any number of regexps. And even more: you can define one regexp for pre-matching and it's result will define which set of actions (including another regexps) it will go through. You could write matching lines in one file, and simultaneously write non-matching to another file. If you pick up <a class="el" href="group__mod__machine__fuse.html">io/fuse</a> for input and run frozen as daemon - this predefined complex pipe will process any data at any time. Grep can't do that.</p>
<p>Prev tutorial: <a class="el" href="group__tutorial__execution.html">Tutorial: starting daemon</a></p>
<p>More tutorials here: <a class="el" href="group__tutorial.html">Tutorials</a> </p>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Tue Feb 21 2012 13:13:59 for frozen by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1</small></address>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7806052-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body>
</html>
