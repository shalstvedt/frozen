<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="keywords" content="frozen, data, processing, big data, daemon, fast, flexible"/>
<title>Destination-irrelevant architecture | frozen - flexible data processing daemon</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">frozen
   &#160;<span id="projectnumber">1.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Destination-irrelevant architecture</div>  </div>
<div class="ingroups"><a class="el" href="group__articles.html">Articles</a></div></div><!--header-->
<div class="contents">
<p>Today many developers use request-based in everything - it is very easy to think in it, easy to understand, easy to use. But that happens next? Next we want to do things fast. Here we go for multi threaded program, event-driven programming, use co-routines, and every single bit we can find to speed this damn thing. And they work too - program speeds up. We see incredible async beasts that handle tens of thousands requests per second, but how about take a look to another approach in programming?</p>
<h2><a class="anchor" id="situation"></a>
Situation</h2>
<p>Let's imagine following situation: we have big cluster of computers, and we have big pile of data in it. We setup some db solution to store this data and retrieve. And this db solution is request-based - we say "i want this data", and server send to to us. Looks good, but i do not want to store and retrive data only. I want to process it and write it back in another place. And what happens? Single tiny client request huge pile of data, receive it over network, with some magic and time it process all that data and then send data back to cluster. Do you see bottleneck?</p>
<h2><a class="anchor" id="solution1"></a>
Obvious solution</h2>
<p>Yes, we can setup more advanced software over cluster to run program over all computers in cluster. Then we need some split data algo, and it would be good if it use same machine for processing where data stored. Then we need some management software to start our program and watch how our system do. May be we hire OpenMP guy to make one huge program to run on cluster. And so on.</p>
<p>Too complex, too time-consuming, too costly.</p>
<h2><a class="anchor" id="solution2"></a>
Less obvious solution</h2>
<p>Rethink architecture. May be we can somehow to fix this. What if i do not download all that data, but say there i want it to flow to. That would be easy - tiny client send request with destination inside, and destination itself is huge processing system which is easy to build with ZeroMQ. So, in this environment client can download data and use it by himself (an old way), can pass data to another destination (new way). And even more, that destination can flow resulting data to any destination too. Request can have any number of nested destinations. I can even pass some data to client back, i can ask client to solve some specific job and get results back in system.</p>
<p>From higher point of view it would look even better. Lets say "company 1" do X with data, and other "company 2" do Y with data. We have data and we want to get X(Y(data)). I make request to company 1 to process data and send it to company 2, which in turn process incoming data and return it to me back. I'm not in middle of 1 and 2, and i would not see that intermediate data and i really do not want to see or store or retransmit it. That helps to same time and space a bit.</p>
<p>More - company 2 can use our own secret code Z to make Y processing even better. But we do not want to give them Z, nor access to api, nor pay to them to adapt their code to use our api. With this new architecture i can do it easy (of course company 1 and 2 need to support it too) I supply temporary zeromq socket to my request, and company 2 see - there is service available - it can use it. Then processing completes - temporary access closed and no one can use our code.</p>
<h2><a class="anchor" id="example"></a>
Real example</h2>
<p>In frozen we can do like that very easy. It use ZeroMQ to build distributed systems, and it can pass sockets inside requests. Our service in turn see socket in request, unpack it, and use it to send data to next destination.</p>
<p>Code for service A: </p>
<div class="fragment"><pre class="fragment">include(daemon.m4)
include(shop.m4)
include(zeromq.m4)

include(article_flow_config.m4)

SHOP(`service_a&#39;,
`
        { <span class="keyword">class </span>= &quot;assign&quot;, before = {                                <span class="comment">// add some data to request</span>
                data1 = <span class="stringliteral">&quot;service_a&quot;</span>
        }},
        

        { <span class="keyword">class </span>= &quot;implode&quot;, buffer = (hashkey_t)<span class="stringliteral">&quot;buffer&quot;</span> },          <span class="comment">// send to socket in request</span>
        { <span class="keyword">class </span>= &quot;modules/zeromq&quot;,
                socket  = (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;destination&quot;</span>,
                input   = (hashkey_t)<span class="stringliteral">&quot;buffer&quot;</span>,
                convert = (uint_t)<span class="stringliteral">&quot;1&quot;</span>
        },
        { <span class="keyword">class </span>= &quot;end&quot; }
&#39;)

DAEMON(`                                                              <span class="comment">// worker code to connect to zeromq router and get requests</span>
        ZEROMQ_HASH_PULL(`SERVICE_A_WORKER_connect&#39;, `service_a&#39;)
&#39;)

{ <span class="keyword">class </span>= &quot;end&quot; }
</pre></div><p>Code for service B: </p>
<div class="fragment"><pre class="fragment">include(daemon.m4)
include(shop.m4)
include(zeromq.m4)

include(article_flow_config.m4)

SHOP(`service_b&#39;,
`
        { <span class="keyword">class </span>= &quot;assign&quot;, before = {                                 <span class="comment">// add some data here too</span>
                data2 = <span class="stringliteral">&quot;service_b&quot;</span>
        }},
        
        { <span class="keyword">class </span>= &quot;query&quot;,                                             <span class="comment">// print all results</span>
                data = (<a class="code" href="structcontainer__t.html" title="container_t structure">container_t</a>){
                        <span class="stringliteral">&quot;client data: &quot;</span>,        (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;data&quot;</span>,
                        <span class="stringliteral">&quot;\nservice a data: &quot;</span>,   (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;data1&quot;</span>,
                        <span class="stringliteral">&quot;\nservice b data: &quot;</span>,   (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;data2&quot;</span>,
                        <span class="stringliteral">&quot;\n&quot;</span>
                },
                request = {
                        action      = (action_t)<span class="stringliteral">&quot;convert_to&quot;</span>,
                        destination = (<a class="code" href="structfd__t.html">fd_t</a>)<span class="stringliteral">&quot;stdout&quot;</span>
                }
        }
<span class="stringliteral">&#39;)</span>
<span class="stringliteral"></span>
<span class="stringliteral">DAEMON(`                                                               // worker code to connect to zeromq router and get requests</span>
<span class="stringliteral">        ZEROMQ_HASH_PULL(`SERVICE_B_WORKER_connect&#39;</span>, `service_b<span class="stringliteral">&#39;)</span>
<span class="stringliteral">&#39;</span>)

{ <span class="keyword">class </span>= &quot;end&quot; }
</pre></div><p>Code for client: </p>
<div class="fragment"><pre class="fragment">include(zeromq.m4)

include(article_flow_config.m4)

{ <span class="keyword">class </span>= &quot;thread&quot; }, 

{ <span class="keyword">class </span>= &quot;assign&quot;, before = {                                             <span class="comment">// set our data</span>
        data = (<a class="code" href="structraw__t.html">raw_t</a>)<span class="stringliteral">&quot;client_data&quot;</span>
}},

ZEROMQ_HASH_PUSH(`SERVICE_A_connect<span class="stringliteral">&#39;, `                                    // push our request</span>
<span class="stringliteral">        destination = ZEROMQ_LAZY_SOCKET(`push&#39;</span>, `SERVICE_B_connect<span class="stringliteral">&#39;),     // - our destination socket - it is service B</span>
<span class="stringliteral">        data        = (env_t)&quot;data&quot;                                        // - our data</span>
<span class="stringliteral">&#39;</span>),
{ <span class="keyword">class </span>= &quot;end&quot; }
</pre></div><p>We start in different consoles: </p>
<div class="fragment"><pre class="fragment">  $ frozend -c article_flow_router.m4
  $ frozend -c article_flow_servicea.m4
  $ frozend -c article_flow_serviceb.m4
</pre></div><p>And run this on client: </p>
<div class="fragment"><pre class="fragment"> $ frozend -c article_flow_client.m4
</pre></div><p>In result we see following in service B console: </p>
<div class="fragment"><pre class="fragment"> $ frozend -c article_flow_serviceb.m4 
 client data: client_data
 service a data: service_a
 service b data: service_b
</pre></div><p>Here we see data we set in client, data which service A set, and service B.</p>
<h2><a class="anchor" id="real_world"></a>
Real world</h2>
<p>Examples are cool, but can be not so good in real world. However, i use it to run my crawler project. I have crawler as "service A" and html processing engine as "service B". I can add as many crawlers and process engines in any time i want and shut them down too. Unfortunately, piece of code for crawler and processing engine would remain closed for a while. Rest of system - frozen and all that distributed stuff is open-source and you free to use it. </p>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated for frozen by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a></small></address>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7806052-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body>
</html>
