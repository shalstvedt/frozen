<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="keywords" content="frozen, data, processing, big data, daemon, fast, flexible"/>
<title>Flow-based programming intro | frozen - flexible data processing daemon</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">frozen
   &#160;<span id="projectnumber">1.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Flow-based programming intro</div>  </div>
<div class="ingroups"><a class="el" href="group__articles.html">Articles</a></div></div><!--header-->
<div class="contents">
<h2><a class="anchor" id="simple_copy"></a>
Copying files in simple way</h2>
<p>What could be simplier than to copy file? May be this is not very interesting way to spend your time, but lets take a look how we can do job using frozen and it's flow-based nature. First, assume we want to copy file within same computer. We need to open both files, read some from one file to buffer, write this buffer to second file, and in both steps monitor return codes, right? No. We just call "transfer" method on file, like so:</p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;emitter&quot;, request = {
        request = {
                action      = (action_t)<span class="stringliteral">&quot;transfer&quot;</span>,
                source      = (file_t){ filename = <span class="stringliteral">&quot;INPUT&quot;</span>  },
                destination = (file_t){ filename = <span class="stringliteral">&quot;OUTPUT&quot;</span> }
        },
        machine = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                { <span class="keyword">class </span>= &quot;data/query&quot;, data = (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;source&quot;</span> },
                { <span class="keyword">class </span>= &quot;kill&quot; }
        }
}},
{ <span class="keyword">class </span>= &quot;end&quot; }
</pre></div> <div class="fragment"><pre class="fragment">   $ frozend -c examples/article_cp_01_simple.m4 -o <span class="stringliteral">&quot;-DINPUT=TODO -DOUTPUT=TODO.bak&quot;</span>
</pre></div><p> That was pretty easy. But that if we want to copy file from different machines?</p>
<h2><a class="anchor" id="l2r_copy"></a>
Copying file to another computer</h2>
<p>If we want to copy something to another machine usually we call scp or rsync, but i always wanted to do this using ZeroMQ socket. So, let's do it! We need to open file, open zmq socket, read some info from file and then send message, then repeat until file ends, right? Again, no, and again, we use "transfer". Out (client) side configuration file will look like so:</p>
<div class="fragment"><pre class="fragment">include(examples/article_cp_common.m4)

FILE(`remote_file&#39;, `8888&#39;)

{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;emitter&quot;, request = {
        request = {
                action      = (action_t)<span class="stringliteral">&quot;transfer&quot;</span>,
                source      = (file_t){ filename = <span class="stringliteral">&quot;INPUT&quot;</span> },
                destination = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>)<span class="stringliteral">&quot;remote_file&quot;</span>
        },
        machine = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                { <span class="keyword">class </span>= &quot;data/query&quot;, data = (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;source&quot;</span> },
                { <span class="keyword">class </span>= &quot;kill&quot; }
        }
}},
{ <span class="keyword">class </span>= &quot;end&quot; }
</pre></div><p>Not much changes for completely different destination. FILE macro hides some magic, it define new machine with given name and zeromq port. This machine pass all requests to remote side for zeromq socket and get reply from it. Transfer routine of file didn't know there actual write goes, so it could be anywhere, even on another machine.</p>
<p>Let's take a look at server side, maybe it is very complex?</p>
<div class="fragment"><pre class="fragment">include(implode.m4)

{ <span class="keyword">class </span>= &quot;thread&quot;, loop = (uint_t)<span class="stringliteral">&quot;1&quot;</span> },
{
        <span class="keyword">class  </span>= &quot;modules/zeromq&quot;,
        socket = (zeromq_t){
                type = <span class="stringliteral">&quot;rep&quot;</span>,
                bind = <span class="stringliteral">&quot;tcp://127.0.0.1:8888&quot;</span>
        },
        shop = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                EXPLODE(`buffer<span class="stringliteral">&#39;, `buffer&#39;</span>,
                `
                        { <span class="keyword">class </span>= &quot;query&quot;, data = (file_t){ filename = <span class="stringliteral">&quot;OUTPUT&quot;</span> } }
                <span class="stringliteral">&#39;),</span>
<span class="stringliteral">                { class = &quot;shop/return&quot; }</span>
<span class="stringliteral">        }</span>
<span class="stringliteral">},</span>
<span class="stringliteral">{ class = &quot;end&quot; }</span>
</pre></div><p>Not at all. It have endless thread which read from zeromq socket, then EXPLODE request from incoming message and pass it to file. To use this we run in shell following commands: </p>
<div class="fragment"><pre class="fragment">   $ frozend -c examples/article_cp_02_server.m4 -o <span class="stringliteral">&quot;-DOUTPUT=TODO.bak&quot;</span> &amp;
   $ frozend -c examples/article_cp_02_client.m4 -o <span class="stringliteral">&quot;-DINPUT=TODO&quot;</span>
</pre></div><h2><a class="anchor" id="r2r_copy"></a>
Copying files between computers</h2>
<p>Next step is to copy between two computers. Client:</p>
<div class="fragment"><pre class="fragment">include(examples/article_cp_common.m4)

FILE(`remote_file1&#39;, `8888&#39;)
FILE(`remote_file2&#39;, `8887&#39;)

{ <span class="keyword">class </span>=&gt; &quot;daemon/thread&quot; },
{ <span class="keyword">class </span>=&gt; &quot;emitter&quot;, request = {
        request = {
                action      = (action_t)<span class="stringliteral">&quot;transfer&quot;</span>,
                source      = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>)<span class="stringliteral">&quot;remote_file1&quot;</span>,
                destination = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>)<span class="stringliteral">&quot;remote_file2&quot;</span>
        },
        machine = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                { <span class="keyword">class </span>= &quot;data/query&quot;, data = (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;source&quot;</span> },
                { <span class="keyword">class </span>= &quot;kill&quot; }
        }
}},
{ <span class="keyword">class </span>= &quot;end&quot; }
</pre></div><p>Pretty obvious changes. We replace file to special machine and everything works just fine. Server side is same, just some macro added. To see it in action: </p>
<div class="fragment"><pre class="fragment">   frozend -c examples/article_cp_03_server.m4 -o <span class="stringliteral">&quot;-DFILE=TODO -DPORT=8888&quot;</span> &amp;
   frozend -c examples/article_cp_03_server.m4 -o <span class="stringliteral">&quot;-DFILE=TODO.bak -DPORT=8887&quot;</span> &amp;
   frozend -c examples/article_cp_03_client.m4 
</pre></div><p> However, data from file flows through our (client) computer and this is not so good. Possible solutions: </p>
<ul>
<li>Pass zeromq socket as destination itself. Yes we can transfer socket object from one computer to another and everything would work fine, but unfortunately "transfer" method not well suitable for this. This is because socket is waiting for clean data and transfer will pass clean data, but other side server is expecting not clean data, but request. So, we need to do special server side - not best solution. </li>
<li>Make "transfer" daemon. It would be standalone daemon, which would listen to our requests and will initiate transfer. Data would flow through daemon. Still not best. </li>
<li>Make "proxy" pattern for zeromq socket. In this pattern socket act as proxy, passing real requests to it to another end. This will not require server-side changes. Cool, but it not yet implemented, but would be.</li>
</ul>
<h2><a class="anchor" id="enum_fun"></a>
Enumerating things on LevelDB</h2>
<p>Copying files led us to nice idea - why bother to get data to ourselves, let's shoot everything with it. Last nice example would be remote LevelDB instance using our favorite ZeroMQ sockets.</p>
<div class="fragment"><pre class="fragment">include(shop.m4)
include(implode.m4)

<span class="comment">// we are here</span>
{ <span class="keyword">class </span>= &quot;thread&quot; },
{ <span class="keyword">class </span>= &quot;emitter&quot;, request = {                        <span class="comment">// write key to db</span>
        request = {
                action = (action_t)<span class="stringliteral">&quot;write&quot;</span>,
                key    = (<a class="code" href="structraw__t.html">raw_t</a>)<span class="stringliteral">&quot;testkey&quot;</span>,
                value  = (<a class="code" href="structraw__t.html">raw_t</a>)<span class="stringliteral">&quot;testvalue\n&quot;</span>
        },
        machine = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                SHOP_QUERY(`leveldb<span class="stringliteral">&#39;),</span>
<span class="stringliteral">                { class = &quot;end&quot; }</span>
<span class="stringliteral">        }</span>
<span class="stringliteral">}},</span>
<span class="stringliteral"></span>
<span class="stringliteral">{ class = &quot;emitter&quot;, request = {                        // read key from db</span>
<span class="stringliteral">        request = {</span>
<span class="stringliteral">                action = (action_t)&quot;read&quot;,</span>
<span class="stringliteral">                key    = (raw_t)&quot;testkey&quot;,</span>
<span class="stringliteral">                value  = (raw_t)&quot;error\n&quot;</span>
<span class="stringliteral">        },</span>
<span class="stringliteral">        machine = (machine_t){</span>
<span class="stringliteral">                SHOP_QUERY(`leveldb&#39;</span>),
                { <span class="keyword">class </span>= &quot;data/query&quot;, data = (<a class="code" href="structfd__t.html">fd_t</a>)<span class="stringliteral">&quot;stdout&quot;</span>, request = {
                        action = (action_t)<span class="stringliteral">&quot;write&quot;</span>,
                        buffer = (<a class="code" href="structenv__t.html">env_t</a>)<span class="stringliteral">&quot;value&quot;</span>
                }},
                { <span class="keyword">class </span>= &quot;end&quot; }
        }
}},

{ <span class="keyword">class </span>= &quot;emitter&quot;, request = {                        <span class="comment">// enumerate db</span>
        request = {
                action = (action_t)<span class="stringliteral">&quot;enum&quot;</span>,
                data   = (zeromq_t){                    <span class="comment">// our zeromq socket, we pass it to db, so it could use it</span>
                        type    = <span class="stringliteral">&quot;push&quot;</span>,
                        connect = <span class="stringliteral">&quot;tcp://127.0.0.1:8887&quot;</span>,
                        lazy    = (uint_t)<span class="stringliteral">&quot;1&quot;</span>
                }
        },
        machine = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                SHOP_QUERY(`leveldb<span class="stringliteral">&#39;),</span>
<span class="stringliteral">                { class = &quot;assign&quot;, before = {</span>
<span class="stringliteral">                        myenum = (zeromq_t){            // this socket we use to get data</span>
<span class="stringliteral">                                type = &quot;pull&quot;,</span>
<span class="stringliteral">                                bind = &quot;tcp://127.0.0.1:8887&quot;</span>
<span class="stringliteral">                        },</span>
<span class="stringliteral">                        buffer = (raw_t){}</span>
<span class="stringliteral">                }},</span>
<span class="stringliteral">                </span>
<span class="stringliteral">                { class = &quot;modules/mustache&quot;, template = &quot;Items list:\n{{#myenum}} - {{data}}\n{{/myenum}}&quot;, output = (hashkey_t)&quot;buffer&quot; },</span>
<span class="stringliteral">                { class = &quot;data/query&quot;, data = (fd_t)&quot;stdout&quot;, request = {</span>
<span class="stringliteral">                        action = (action_t)&quot;write&quot;,</span>
<span class="stringliteral">                        buffer = (env_t)&quot;buffer&quot;</span>
<span class="stringliteral">                }},</span>
<span class="stringliteral">                { class = &quot;end&quot; }</span>
<span class="stringliteral">        }</span>
<span class="stringliteral">}},</span>
<span class="stringliteral">{ class = &quot;kill&quot; },</span>
<span class="stringliteral">NULL,</span>
<span class="stringliteral"></span>
<span class="stringliteral">// helper routines</span>
<span class="stringliteral">SHOP(`leveldb&#39;</span>,
`       IMPLODE(`input<span class="stringliteral">&#39;, `output&#39;</span>,
        `{
                <span class="keyword">class  </span>= &quot;modules/zeromq&quot;,
                socket = (zeromq_t){
                        type = <span class="stringliteral">&quot;req&quot;</span>,
                        connect = <span class="stringliteral">&quot;tcp://127.0.0.1:8888&quot;</span>
                },
                input  = (hashkey_t)<span class="stringliteral">&quot;input&quot;</span>,
                output = (hashkey_t)<span class="stringliteral">&quot;output&quot;</span>
        }<span class="stringliteral">&#39;)</span>
<span class="stringliteral">&#39;</span>)

<span class="comment">// -----------------------------------------------------------</span>
<span class="comment">// leveldb server</span>

{ <span class="keyword">class </span>= &quot;thread&quot;, loop = (uint_t)<span class="stringliteral">&quot;1&quot;</span> },
{
        <span class="keyword">class  </span>= &quot;modules/zeromq&quot;,
        socket = (zeromq_t){
                type = <span class="stringliteral">&quot;rep&quot;</span>,
                bind = <span class="stringliteral">&quot;tcp://127.0.0.1:8888&quot;</span>
        },
        shop = (<a class="code" href="structmachine__t.html" title="Machine structure.">machine_t</a>){
                EXPLODE(`buffer<span class="stringliteral">&#39;, `buffer&#39;</span>,
                `{
                        <span class="keyword">class </span>= &quot;modules/leveldb&quot;,
                        path  = <span class="stringliteral">&quot;test_leveldb/&quot;</span>
                }
                <span class="stringliteral">&#39;),</span>
<span class="stringliteral">                { class = &quot;shop/return&quot; }</span>
<span class="stringliteral">        }</span>
<span class="stringliteral">},</span>
<span class="stringliteral">{ class = &quot;end&quot; }</span>
<span class="stringliteral"></span>
</pre></div><p>As you can see, to enumerate database items we pass socket. And we can point this socket to any point in your network. But to see than it is actually working we point to ourselves and get all data. Notice how our (incoming) socket used in mustache parser. It use real object to enumerate it and zeromq support it, returning all messages as items with key "data". </p>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 16 2012 14:29:27 for frozen by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.0</small></address>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7806052-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body>
</html>
